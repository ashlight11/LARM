from __future__ import print_function
from os import posix_fadvise
from tkinter import Frame
import cv2 as cv
import numpy
import math
import datetime
import rospy, rospkg
from geometry_msgs.msg import Pose
from sensor_msgs.msg import Image
from kobuki_msgs.msg import Led
from cv_bridge import CvBridge, CvBridgeError


# Get an instance of RosPack with the default search paths
def get_pkg_path():
    rospack = rospkg.RosPack()
    return rospack.get_path('grp-poire')

# Class dedicated to image processing with opencv
class BottleDetectionOnly():
    def __init__(self) :
        nuka_cascade_name = get_pkg_path() + "/XML_model/cascade.xml"
        self.nuka_cascade = cv.CascadeClassifier()
        self.camera_width = 1920.0
        self.camera_height = 1080.0
        self.hfov = 64

        # Load the cascade, i.e. the XML file generated by the model training
        if not self.nuka_cascade.load(cv.samples.findFile(nuka_cascade_name)):
            print('--(!)Error loading face cascade')
            exit(0)
        
        # Get the depth camera images
        rospy.Subscriber("/camera/aligned_depth_to_color/image_raw", Image, self.depthCallback)

        # Get the BGR camera images
        rospy.Subscriber("camera/color/image_raw", Image, self.rgbImageCallback)

        # Publisher to alert when a bottle is found with an estimated position
        self.posePublisher = rospy.Publisher("alert_bottle", Pose, queue_size=10)

        # Publisher to turn on Led 1 if bottle is found
        self.ledPublisher = rospy.Publisher("/mobile_base/commands/led1", Led, queue_size=10)
        self.imagePublisher = rospy.Publisher("bottle_images", Image, queue_size=10)

    # Actual image processing is done here
    def detectAndDisplay(self, frame):
        frame_gray = cv.cvtColor(frame, cv.COLOR_BGR2GRAY) # convert to gray image
        frame_gray = cv.equalizeHist(frame_gray) # equalize to minimize flaws
        color_info = (255, 255, 255) # color for tex to be written on the frames

        # -- Detect black bottles
        bottles = self.nuka_cascade.detectMultiScale(
            frame_gray, minNeighbors=30, scaleFactor=3)
        for (x, y, w, h) in bottles:
            crop_frame = frame[y:y+h, x:x+w]
            median = numpy.median(crop_frame)
            #print("height " + str(frame.shape[0])  + "  width : " + str(frame.shape[1]))
            if median > 170 and y > frame.shape[0] / 3:
                cv.rectangle(frame, (x, y), (x+w, y+h), (255, 0, 0), 2)
                estimated_pose = self.estimatePose(x,y, w, h)
                self.posePublisher.publish(estimated_pose)
                self.sendImage(frame)
                self.turnOnLed()
                self.latestTurnOn = datetime.datetime.now()
                '''cv.imshow('Capture - Black Cola detection', frame)
                cv.waitKey(400)'''
                
        # -- Detect orange bottles 
        color = 8 # Hue value for bright orange 
        # We can adjust saturation to include more images
        lo = numpy.array([color - 2, 240, 240]) # Slightly darker and dimmer orange
        hi = numpy.array([color + 2, 255, 255]) # Slighty lighter and brighter orange
        image = cv.cvtColor(frame, cv.COLOR_BGR2HSV) # Convert bgr color scheme to hsv
        mask = cv.inRange(image, lo, hi) # bit-mask selecting desired pixel

        # Opencv built-in function to find contours with a mask
        elements = cv.findContours(mask, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE)[-2]
        if len(elements) > 0:
            c = max(elements, key=cv.contourArea)
            x,y,w,h = cv.boundingRect(c)
            if w > 10 and y < 500: # if wide enough and not too low (avoid false positives with orange floor)
                cv.putText(frame, "Objet !", (int(x)+10, int(y) - 10),
                        cv.FONT_HERSHEY_DUPLEX, 1, color_info, 1, cv.LINE_AA)
                # estimate relative position
                estimated_pose = self.estimatePose(x,y, w, h)
                # send alert to other scripts
                self.posePublisher.publish(estimated_pose)
                # send image to RVIZ
                self.sendImage(frame)
                # turn on Led 1
                self.turnOnLed()
                # Timestamp to turn led off after a certain time
                self.latestTurnOn = datetime.datetime.now()
        try:
           if (datetime.datetime.now() - self.latestTurnOn).total_seconds() > 1.0 :
               # Turn off Led if one second has passed
               self.turnOffLed()
        except AttributeError:
            pass
        
    # Compute the estimated position of the bottle with the image processing results
    def estimatePose(self, x, y, w, h):
        distance = 2000
        for row in self.depth_array[y:y+h, x:x+w]:
            for pixel in row:
                if pixel < distance and pixel != 0:
                    distance = pixel  # ros distance with realsense camera
        # angle calculated from the middle of the picture
        angle = ((x+w - self.camera_width/2)/(self.camera_width/2))*(self.hfov/2) * math.pi / 180
        estimated_pose = Pose()
        estimated_pose.position.x = distance / 1000 * math.cos(angle) # equals distance * cos(angle from middle of camera)
        estimated_pose.position.y = - distance / 1000 * math.sin(angle)  # equals distance * sin(angle from middle of camera)
        return estimated_pose
    
    # Turn on the Led 1 with green color
    def turnOnLed(self):
        led = Led()
        led.value = Led.GREEN
        self.ledPublisher.publish(led)

    # Turn off Led 1
    def turnOffLed(self):
        led = Led()
        led.value = Led.BLACK
        self.ledPublisher.publish(led)

    # Publish image to rviz viewer
    def sendImage(self, frame):
        bridge = CvBridge()
        # Necessary conversion between opencv frame and sensor_msg Image
        image_message = bridge.cv2_to_imgmsg(frame, encoding="passthrough")
        self.imagePublisher.publish(image_message)

    # Get the depth calema
    def depthCallback(self, data):
        bridge = CvBridge()
        # Try to convert the ROS Image message to a CV2 Image
        try:
            cv_image = bridge.imgmsg_to_cv2(data)
        except CvBridgeError as e:
            rospy.logerr("CvBridge Error: {0}".format(e))
        # Convert the array of values to an exploitable numpy array
        self.depth_array = numpy.array(cv_image, dtype=numpy.float32)
    
    # Get the color camera
    def rgbImageCallback(self, data: Image):
        bridge = CvBridge()
        # Try to convert the ROS Image message to a CV2 Image
        try:
            cv_image = bridge.imgmsg_to_cv2(data, "bgr8")
        except CvBridgeError as e:
            rospy.logerr("CvBridge Error: {0}".format(e))
        # Image Processing started here
        self.detectAndDisplay(cv_image)

if __name__ == '__main__':
    try:
    # Initialize ROS::node
        rospy.init_node('Bottle_Detection_Image_Processing', anonymous=True)
        node = BottleDetectionOnly()
        rospy.spin()
    except rospy.ROSInterruptException:
        pass

    
    